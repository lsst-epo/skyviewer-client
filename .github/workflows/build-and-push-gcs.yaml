name: Build, Push, and Deploy

on:
  push:
    branches:
       - 'develop'
       - 'main'
       - '332-gcs-build' # temporary for testing
    tags:
      - 'v*'
  pull_request:
    types:
      - labeled
      - 'opened'
      - 'synchronize'
      - 'reopened'
    branches:
      - 'develop'
      - 'main'
env:
  DOCKER_IMAGE_NAME: "nextjs-client-build"
jobs:
  build:
    if: ${{ github.event_name == 'push' || contains(github.event.pull_request.labels.*.name, 'preview') || github.event.label.name == 'preview' }}
    name: Build Container Image
    runs-on: ubuntu-latest
    environment: SKYVIEWER_DEV # Just for dev purposes
    outputs:
      image_tag: ${{ steps.deploy-tag.outputs.image_tag }}
      image_name: ${{ steps.deploy-tag.outputs.image_name }}
      environment_name: ${{ steps.deploy-info.outputs.environment_name }}
      date: ${{ steps.deploy-info.outputs.date }}
    steps:
      -
        name: Checkout
        uses: actions/checkout@v4.2.1
      -
        name: Parse deployment info
        id: deploy-info
        run: |
          # Determine environment to deploy to
          if ${{ github.ref_type == 'tag'}}; then
            environment_name="prod"
            credentials_json='${{ secrets.PIPELINE_EPO_PROD_PROJECT }}'
          elif ${{ contains(github.ref_name, 'main') || contains(github.base_ref, 'main') }}; then
            environment_name="int"
            credentials_json='${{ secrets.SKYVIEWER_INT_SERVICE_ACCOUNT }}'
          else
            environment_name="dev"
            credentials_json='${{ secrets.DEV_SA_KEY }}'
          fi
          echo environment_name=$environment_name >> "$GITHUB_OUTPUT"
          echo credentials_json=$credentials_json >> "$GITHUB_OUTPUT"
          echo date=$(date +'%Y%m%d') >> $GITHUB_OUTPUT
      -
        name: Docker meta
        id: meta
        uses: docker/metadata-action@v5.6.1
        with:
          # list of Docker images to use as base name for tags
          images: |
            gcr.io/skyviewer/skyviewer-client-k8s,enable=${{ steps.deploy-info.outputs.environment_name == 'dev' }}
            gcr.io/edc-int-6c5e/skyviewer-client-k8s,enable=${{ steps.deploy-info.outputs.environment_name == 'int' }}
            gcr.io/edc-prod-eef0/skyviewer-client-k8s,enable=${{ steps.deploy-info.outputs.environment_name == 'prod' }}
          flavor: |
            latest=${{ github.event_name == 'push'}}
          # generate Docker tags based on the following events/attributes
          tags: |
            type=schedule
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=sha
      -
        name: Parse deploy tag
        id: deploy-tag
        run: |
          # Parse container image tag to deploy
          full_tag=$(echo "$DOCKER_METADATA_OUTPUT_JSON" | jq -r '.tags[0]')
          echo "Will use tag \"$full_tag\" for deployment."
          echo image_tag=$(echo "$full_tag" | cut -f2 -d:) >> "$GITHUB_OUTPUT"
          echo image_name=$(echo "$full_tag" | cut -f1 -d:) >> "$GITHUB_OUTPUT"
          echo full_tag=$full_tag >> "$GITHUB_OUTPUT"
          echo bucket_name=skyviewer-{{ steps.deploy-info.outputs.environment_name }} >> "$GITHUB_OUTPUT"
          echo bucket_subfolder=$(echo "$full_tag" | cut -f2 -d:)-${{ steps.deploy-info.outputs.date }} >> "$GITHUB_OUTPUT"
      -
        name: Set up QEMU
        uses: docker/setup-qemu-action@v3.3.0
      -
        name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3.8.0
      -
        name: Login to GCP
        uses: 'google-github-actions/auth@v2.1.7'
        with:
          credentials_json: ${{ steps.deploy-info.outputs.credentials_json }}
      -
        name: 'Set up Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v2.1.2'
      -
        run: gcloud --quiet auth configure-docker
      -
        name: Build and push
        uses: docker/build-push-action@v6.11.0
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-to: |
            type=gha
          cache-from: |
            type=gha
          build-args: |
            BASE_TAG=k8s
            RUN_BUILD=false
      -
        uses: imjasonh/setup-crane@v0.4
        if: ${{ github.event_name == 'pull_request' }}
      -
        name: Preview prep
        if: ${{ github.event_name == 'pull_request' }}
        run: |-
          CLIENT_IMAGE=$(echo "${{ steps.deploy-tag.outputs.image_name }}" | sed -e 's/-api/-client/g')
          if ! crane config ${CLIENT_IMAGE}:${{ steps.deploy-tag.outputs.image_tag }}; then
            crane tag ${CLIENT_IMAGE}:latest ${{ steps.deploy-tag.outputs.image_tag }}
          fi
      -
        name: Fetch and Set Environment Variables from Secret Manager
        id: deploy-secrets
        if: ${{ steps.deploy-info.outputs.environment_name == 'dev' }}
        env:
          CLIENT_SECRET_NAME: ${{ secrets.GCP_DEV_CLIENT_SECRET_NAME }}
          GCP_PROJECT_ID: ${{ secrets.GCP_DEV_PROJECT_ID }}
        run: |
          # The secret value must be a single-line JSON string.
          SECRET_JSON=$(gcloud secrets versions access latest --secret=${{ env.CLIENT_SECRET_NAME }} --project=${{ env.GCP_PROJECT_ID }})
          
          # Use jq to iterate over the JSON entries.
          #    -r: raw output (no quotes)
          #    to_entries[]: converts the JSON object to an array of objects like {"key":"KEY_NAME", "value":"KEY_VALUE"}
          #    The result is a single string like: --secret id=KEY1,env=KEY1 --secret id=KEY2,env=KEY2 ...
          
          # SECRET_ARGS=$(echo "$SECRETS_JSON" | jq -r 'to_entries[] | "--secret id=\(.key),env=\(.key)"')
          BUILD_ARGS=$(echo "$SECRETS_JSON" | jq -r 'to_entries[] | "--build-arg id=\(.key),env=\(.key)"')

          # Expose the generated arguments to subsequent steps using $GITHUB_ENV
          # echo "DOCKER_SECRET_ARGS=$SECRET_ARGS" >> $GITHUB_ENV
          echo "DOCKER_BUILD_ARGS=$BUILD_ARGS" >> $GITHUB_ENV
      # -
        # name: Access Secret Manager and store JSON
        # id: secret_access
        # uses: google-github-actions/secret-manager-access@v2
        # with:
        #   secret: ${{ secrets.GCP_DEV_CLIENT_SECRET_NAME }}
        #   version: latest
      - 
        name: Run static build in docker container
        run: |
          DOCKER_BUILDKIT=1 docker build \
            ${{ env.DOCKER_BUILD_ARGS }} \
            --target nextjs_copy_from_build \
            --output type=local,dest=./.next \
            .
            # ${{ steps.deploy-tag.outputs.image_name }} .
          # --rm --volume $(pwd):/app ${{ steps.deploy-tag.outputs.image_name }}
      -
        name: Upload to GCS bucket
        uses: 'google-github-actions/upload-cloud-storage@v3'
        with:
          path: '.next'
          destination: ${{ steps.deploy-tag.outputs.bucket_name }}/${{ steps.deploy-tag.outputs.bucket_subfolder }} # bucket_name/prefix

        
      # The `env` section makes the GitHub Secret value available as a RUNNER environment variable.
      # - name: Configure BuildKit Secret Source
      #   env:
      #     BUILD_SECRET_CONTENT: ${{ secrets.MY_BUILD_SECRET }}
      #   run: |
      #     # $BUILD_SECRET_CONTENT holds the actual secret string.
      #     # We export it to $GITHUB_ENV so it's available to the build-push-action step.
      #     # The key must be unique, so we'll use a specific prefix.
      #     echo "BUILD_SECRET_VAR=$BUILD_SECRET_CONTENT" >> $GITHUB_ENV
          
      # --- Docker Build and Export (Using Secret Mount) ---
      # - name: Build Docker Image and Export to Tar (Securely)
      #   id: build-export
      #   uses: docker/build-push-action@v6
      #   with:
      #     context: .
      #     push: false 
      #     outputs: type=tar,dest=/tmp/image-output.tar 
          
      #     # CHANGE: Replacing build-args with the SECURE 'secrets' parameter
      #     # This securely mounts the secret content (read from the $BUILD_SECRET_VAR ENV variable)
      #     # as a file named 'api_key' inside the builder context.
      #     secrets: |
      #       api_key=${{ env.BUILD_SECRET_VAR }}
          
      #     tags: my-app:gcs-artifact-${{ env.IMAGE_TAG_SHA }}
          
          # build-args is removed as it is insecure.
      
      # # --- Upload to GCS ---
      # - name: Upload Docker Image Tarball to GCS
      #   uses: google-github-actions/upload-cloud-storage@v2
      #   with:
      #     path: /tmp/image-output.tar
      #     destination: ${{ env.GCS_BUCKET }}/artifacts/image-${{ env.IMAGE_TAG_SHA }}.tar
          
      - name: Report Success
        run: echo "Successfully built image and uploaded artifact to gs://${{ env.GCS_BUCKET }}/artifacts/image-${{ env.IMAGE_TAG_SHA }}.tar"

      -
        name: Summary
        run: |
          cat <<-EOT >> "$GITHUB_STEP_SUMMARY"
            # Container Build Completed

            ## Tags
            ${{ steps.meta.outputs.tags }}
          EOT

  deploy:
    name: Trigger deploy to ${{ needs.build.outputs.environment_name }}
    needs: build
    runs-on: ubuntu-latest
    if: ${{ github.event_name != 'pull_request' }}
    steps:
      - name: Generate Webhook Payload
        id: payload
        run: |-
          PARAMETERS=(
            client.image.tag=${{ needs.build.outputs.image_tag }}
            client.image.repository=${{ needs.build.outputs.image_name }}
          )
          DATA="{
            \"app_name\": \"skyviewer\",
            \"environment_name\": \"${{ needs.build.outputs.environment_name }}\",
            \"parameters\": $(jq -c -n '$ARGS.positional' --args ${PARAMETERS[@]}),
            \"date\": 
          }"
          echo "data=$(echo $DATA | jq -rc '.')" >> "$GITHUB_OUTPUT"
      - uses: lasith-kg/dispatch-workflow@v2.0.0
        id: dispatch
        name: Trigger Deployment
        with:
          dispatch-method: repository_dispatch
          repo: edc-deploy
          owner: lsst-epo
          event-type: app_update_values
          token: ${{ secrets.EDC_DEPLOY_GITHUB_TOKEN_FOR_REST_API }}
          workflow-inputs: ${{ steps.payload.outputs.data }}
          discover: true
          # can pass data via client_payload (a json string) or workflow-inputs
          # client-payload: '{"branch": "${{ github.ref_name }}", "sha": "${{ github.sha }}", "version": "1.2.3"}'
      - name: Await Run ID ${{ steps.dispatch.outputs.run-id }}
        uses: Codex-/await-remote-run@v1.12.2
        with:
          token: ${{ secrets.EDC_DEPLOY_GITHUB_TOKEN_FOR_REST_API }}
          repo: edc-deploy
          owner: lsst-epo
          run_id: ${{ steps.dispatch.outputs.run-id }}
          run_timeout_seconds: 1500

